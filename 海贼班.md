### 小于input的质数

```c	小于input的所有质数
#include <stdio.h>
#include<math.h>
int main() {
    int input;
    scanf("%d",&input);
    int i;
    int k;
    int z;
        for(int j=2;j<=input;j++){
             k=(int)sqrt( (double)j );//取开平方后的整数部分
            for(z=2;z<=k;z++){
                if(j%z==0) break;
            }
            if(z>k){
                printf("%d\n",j);
            }
        }
    
    return 0;
}
```

### 日期合法性

```c++
#include<cstdio>
int main(){
    int year;
    int month;
    int day;    
    scanf("%d-%d-%d",&year,&month,&day);
    if(month<=12){
        if (month==9||month==6||month==4||month==11){
            if(day<=30){
                printf("YES");
            }else{
                printf("NO");
            }
        }else if(month==2){
            if((year%100!=0&&year%4==0)||year%400==0){
                if(day<=29){
                    printf("YES");
                }else{
                    printf("NO");
                }
            }else{
                if(day<=28){
                    printf("YES");
                }else{
                    printf("NO");
                }
            }    
        }else{
            if(day<=31){
                printf("YES");
            }else{
                printf("NO");
            }
        }
    }else{
        printf("NO");
    } 
    
    return 0;
}
```

### n阶数字正方形

```c	n阶数字正方形
#include <stdio.h>
int main() {
    int number;
    int i;
    int j;
    scanf("%d",&number);
    for(i=1;i<=number;i++){
        for(j=1;j<=number;j++){
            printf("%d",i);
            if(j<number){
              printf(" ");    
            }else{
                printf("\n");
            }          
        }
    }
    return 0;
}
```

### n阶数字三角形

```c	n阶数字三角形
#include <stdio.h>
int main() {
    int number;
    int i;
    scanf("%d",&number);
    for(i=1;i<=number;i++){
        for(int j=1;j<=number-i+1;j++){
            printf("%d",i);
            if(j<number-i+1){
                printf(" ");
            }else{
                printf("\n");
            }
        }
            
    }

    return 0;
}
```

### n阶递减三角形

```c	n阶递减三角形
#include <stdio.h>
int main() {
    int i;
    int number;
    scanf("%d",&number);
    for(i=0;i<=number;i++){
        for(int j=0;j<=number-i-1;j++){
            printf("%d",number-i-j);
            if(j<number-i-1){
                printf(" ");
            }else{
                printf("\n");
            }
                
        }
    }

    return 0;
}
```

### 牛拉法求函数近似值

```c
#include <stdio.h>
#include <math.h>
#define EPSILON 1e-6

double f(double x) {
    return 2 * pow(x, 3) - 4 * pow(x, 2) + 3 * x - 6;
}

double f_prime(double x) {
    return 6 * pow(x, 2) - 8 * x + 3;
}
double h(double x){
    return pow(x,3)-4*pow(x,2)+3*x-6;
}
double h_prime(double x){
    return 3*pow(x,2)-8*x+3;
}
double newton(double(*fp)(double),double(*fp_prime)(double)) {
    double x = 1.5;
    while (fabs(fp(x)) > EPSILON){
        x = x - fp(x) / fp_prime(x);
    }
    return x;
}

int main() {
    printf("%g\n", newton(f,f_prime));
    printf("%g\n",newton(h,h_prime));
    return 0;
}
```

### 二分法求方程根

```c
#include <stdio.h>
#include <math.h>
#define EPSILON 1e-7

double bisection(int p, int q, double (*func)(int, int, double));
double f(int p, int q, double x);
int main() {
    int p;
    int q;
    scanf("%d%d", &p, &q);
    printf("%.4f\n", bisection(p, q, f));
    return 0;
}

double bisection(int p, int q, double (*func)(int, int, double)) {
        double low=-20.0;
        double high=20.0;
        double mid;
        do{   mid = (low+high)/2;
            if (f(p,q,mid)*f(p,q,high)<0){
                low = mid;
            }else if(f(p,q,mid)*f(p,q,high)>0){
                high =mid;
            }
        }while(fabs(f(p,q,mid))>EPSILON);
        return mid;
}

double f(int p, int q, double x) {
    return p * x + q;
}
```

### 筛法列举质数

```c
#include <stdio.h>

int main() {
    int n = 15;
    int mark[16] = {
        1, 1, 0, 0,
        0, 0, 0, 0,
        0, 0, 0, 0,
        0, 0, 0, 0
    };
    int c;
    int j;

    for (c = 2; c * c <= n; c++) {
	  if (mark[c] != 1 ){
        for (j = 2;j <= n/c ; j++){
            mark[c*j] = 1;
        }  
      }
    }
	for(c = 2;c <= n; c++){
        if (mark[c] != 1){
            printf("%d\n",c);
        }
    }
    return 0;
}

```



### 右边界二分查找

```c
int right_bound(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1;
        } else if (nums[mid] == target) {
            // 这里改成收缩左侧边界即可
            left = mid + 1;
        }
    }
    // 这里改为检查 right 越界的情况，见下图
    if (right < 0 || nums[right] != target)
        return -1;
    return right;
}
```

### 左边界二分查找

```c
int left_bound(int[] nums, int target) {
    if (nums.length == 0) return -1;
    int left = 0;
    int right = nums.length; // 注意
    
    while (left < right) { // 注意
        int mid = (left + right) / 2;
        if (nums[mid] == target) {
            right = mid;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid; // 注意
        }
    }
    return left;
}
```

### 二分查找

```c
int Bifind(int nums[],int len,int target){
    int right = len-1;
    int left = 0;
    int mid;
    while(left<=right){
        mid = (left+right)/2;
        if(nums[mid]==target){
            return mid+1;
        }else if(nums[mid]>target){
            right = mid -1;
        }else{
            left = mid+1;
        }
    }
    return 0;
}
```

### 折半查找

```c
#include <stdio.h>
int Bifind(int nums[],int len,int target){
    int right = len-1;
    int left = 0;
    int mid;
    while(left<=right){
        mid = (left+right)/2;
        if(nums[mid]==target){
            return mid+1;
        }else if(nums[mid]>target){
            right = mid -1;
        }else{
            left = mid+1;
        }
    }
    return 0;
}
int main() {
    int n;
    int k;
    int numbers[1000001];
    int m;
    int i;
    int j;
    // 反复读入数字和查找数字的数量
    while (scanf("%d%d", &n, &k) != EOF) {
        
        // 读入给定的数字
        for (i = 0; i < n; i++) {
            scanf("%d", &numbers[i]);
        }
        for (j = 0; j < k; j++) {
            // 读入待查找的数字，
            scanf("%d", &m);
            int r = Bifind(numbers,n,m);
            printf("%d",r);
            if(j<k-1){
                printf(" ");
            }
            // 请在下面完成查找读入数字的功能     
        }

    }
    return 0;
}
```



### 一次走两步或三步，对应n层阶梯，有多少种走法

```c
#include <stdio.h>
int main() {
    int number;
    int s[50];
    s[0] = 0;
    s[1] = 1;
    s[2] = 1;
    for(int i =3;i<50;i++){
        s[i] = s[i-2]+s[i-3];
    }
    scanf("%d",&number);
    printf("%d",s[number-1]);   
    return 0;
}
```

### 冒泡从大到小

```c
#include <stdio.h>

int main() {
    int n = 10;
    int m;
    int numbers[10];
    int i;

    // 读入给定的数字
    for (i = 0; i < n; i++) {
        scanf("%d", &numbers[i]);
    }
    int temp;
    int j;
    for(i = 0;i<n;i++){
        for(j=0;j<n-i-1;j++){
            if(numbers[j]<numbers[j+1]){
                temp = numbers[j];
                numbers[j]=numbers[j+1];
                numbers[j+1]=temp;
            }
        }
    }
    for(i = 0;i<n;i++){
        printf("%d",numbers[i]);
        if(i<n-1){
            printf(" ");
        }
    }
    return 0;
}
```

### 选择排序

```c
#include <stdio.h>

int main() {
    int n = 10;
    int m;
    int numbers[10];
    int i;

    // 读入给定的数字
    for (i = 0; i < n; i++) {
        scanf("%d", &numbers[i]);
    }
    int temp;
    int j;
    for(i = 0;i<n;i++){
        int index = i;
        for(j=i+1;j<n;j++){
            if(numbers[index]<numbers[j]){
                    index=j;
            }
        }
        temp = numbers[index];
        numbers[index] = numbers[i];
        numbers[i]=temp;
    }
    for(i = 0;i<n;i++){
        printf("%d",numbers[i]);
        if(i<n-1){
            printf(" ");
        }
    }
    return 0;
}
```

### 矩阵水平和竖直反转

```c
#include <stdio.h>

int main() {
    int matrix[100][100];
    int m;
    int n;
    scanf("%d %d",&m,&n);
    for(int i = 0;i < m; i++){
        for(int j = 0;j < n;j++){
           scanf("%d",&matrix[i][j]); 
        }
    }
    int bo;
    scanf("%d",&bo);
    if(bo == 0){
        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                printf("%d",matrix[m-i-1][j]);
                if(j<n-1){
                    printf(" ");
                }
            }
            printf("\n");
        }
    }else{
       for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                printf("%d",matrix[i][n-j-1]);
                if(j<n-1){
                    printf(" ");
                }                
            }
            printf("\n");
        }        
    }
    return 0;
}
```

### 3*3矩阵90度旋转

```c
#include <stdio.h>

int main() {
    int matrix[3][3];
    int i;
    int j;
    for(i = 0; i < 3; i++){
        for(j = 0; j < 3; j++){
            scanf("%d", &matrix[i][j]);
        }
    }
    for(i = 0; i < 3; i++){
        for(j = 0; j < 3; j++){
            printf("%d",matrix[2-j][i]);
            if(j<2){
                printf(" ");
            }
        }
        printf("\n");
    }
    return 0;
}
```

### 螺旋输出二维数组

```c++
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        if (matrix.size() == 0 || matrix[0].size() == 0) {
            return {};
        }

        int rows = matrix.size(), columns = matrix[0].size();
        vector<int> order;
        int left = 0, right = columns - 1, top = 0, bottom = rows - 1;
        while (left <= right && top <= bottom) {
            for (int column = left; column <= right; column++) {
                order.push_back(matrix[top][column]);
            }
            for (int row = top + 1; row <= bottom; row++) {
                order.push_back(matrix[row][right]);
            }
            if (left < right && top < bottom) {
                for (int column = right - 1; column > left; column--) {
                    order.push_back(matrix[bottom][column]);
                }
                for (int row = bottom; row > top; row--) {
                    order.push_back(matrix[row][left]);
                }
            }
            left++;
            right--;
            top++;
            bottom--;
        }
        return order;
    }
};
```

```c
int *spiralOrder(int **matrix, int matrixSize, int *matrixColSize, int *returnSize)
{
    if(matrixSize==0){
        *returnSize = 0;
        return NULL;
    }
    int top = 0, bottom = matrixSize - 1, left = 0, right = *matrixColSize - 1;
    int totalElement = *matrixColSize * matrixSize;
    *returnSize = totalElement;
    int *res = (int *)malloc(sizeof(int) * totalElement);
    int m=0, n=0;
    int direction = 0;
    // 0:right   1:down   2:left   3:up
    for(int i=0; i<totalElement; i++){
        switch (direction)
        {
            case 0:
                res[i] = matrix[m][n];
                if(n==right){
                    top++;
                    direction = 1;
                    m++;
                }
                else{
                    n++;
                }
                break;
            case 1:
                res[i] = matrix[m][n];
                if(m==bottom){
                    right--;
                    direction=2;
                    n--;
                }
                else{
                    m++;
                }
                break;

            case 2:
                res[i] = matrix[m][n];
                if(n==left){
                    bottom--;
                    direction = 3;
                    m--;
                }
                else{
                    n--;
                }
                break;

            case 3:
                res[i] = matrix[m][n];
                if(m==top){
                    left++;
                    direction=0;
                    n++;
                }
                else{
                    m--;
                }
                break;

            default:
                break;
        }
    }
    return res;
}

```

### 带空格版本

```c
#include <stdio.h>

int main() {
    int matrix[100][100];
    int m;
    int n;
    scanf("%d %d",&m,&n);
    for(int i = 0; i < m; i++){
        for(int j = 0; j < n; j++){
            scanf("%d",&matrix[i][j]);
        }
    }
    int left = 0;
    int right = n-1;
    int top = 0;
    int bottom = m-1;
    int nums = n*m;//计数输出空格
    while(left <= right && top <= bottom){
        for(int i = left; i <=right; i++){
            printf("%d",matrix[top][i]);
            nums--;
            if(nums!=0){
                printf(" ");
            }    
        }
        for(int i = top+1; i <= bottom; i++){
            printf("%d",matrix[i][right]);
            nums--;
            if(nums!=0){
                printf(" ");
            }
        }
        if(left<right && top<bottom){
            for(int i = right - 1; i >= left; i--){
                printf("%d",matrix[bottom][i]);
                nums--;
                if(nums!=0){
                    printf(" ");
            }
            }
            for(int i = bottom-1; i > top; i--){
                printf("%d",matrix[i][left]);
                nums--;
                if(nums!=0){
                    printf(" ");
                }
            }
        }
     left++;
     right--;
     top++;
     bottom--;        
    }
    return 0;
}
```

### 输出char数组中大小写数字和空格的个数（如何输入带空格的字符是关键）

```c
#include <stdio.h>
void upper_case_count(char arr[31]) {
    // 请在下面实现统计并输出大写字母个数的功能
    int nums = 0; 
    for(int i =0; i <= 30; i++){
        if( arr[i]>=65&&arr[i]<=90){
            nums++;
        }
    }
    printf("%d\n",nums);
}
void lower_case_count(char arr[31]) {
    // 请在下面实现统计并输出小写字母个数的功能
        int nums = 0; 
    for(int i =0; i <= 30; i++){
        if( arr[i]>=97&&arr[i]<=122){
            nums++;
        }
    }
    printf("%d\n",nums);
}
void digit_count(char arr[31]) {
    // 请在下面实现统计并输出数字个数的功能
            int nums = 0; 
    for(int i =0; i <= 30; i++){
        if( arr[i]>=48&&arr[i]<=57){
            nums++;
        }
    }
    printf("%d\n",nums);
}
 
void space_count(char arr[31]) {
    // 请在下面实现统计并输出空格个数的功能
            int nums = 0; 
    for(int i =0; i <= 30; i++){
        if( arr[i]==32){
            nums++;
        }
    }
    printf("%d",nums);
 
}

int main() {
    char string[31];
    int i;
    for(i = 0; i <= 30; i++){
        scanf("%[^\n]",&string);//这样可以使输入带有空格也可以完整输入
    }
    //printf("%s",string);
    
    upper_case_count(string);
    lower_case_count(string);
    digit_count(string);
    space_count(string);
    return 0;
    
}
```



### 辗转相除法求最大公约数和最小公倍数

```c
#include <stdio.h>
int gcd(int n, int m);
int lcm(int n, int m);
int main() {
    int n, m;
    scanf("%d%d", &n, &m);  
    printf("%d\n", gcd(n, m));
    printf("%d\n", lcm(n, m));
    return 0;
}
int gcd(int n, int m) {
    if (m <= n) {
    // 请在这里继续完成 gcd 函数
    if(m == n){
        return m;
    }else{
        return gcd(m,n-m);
    }
    } else {
        return gcd(m, n);
    }
}
int lcm(int n, int m) {
// 请在这里继续完成 lcm 函数
    return n*m/gcd(m,n);
}
```

### 矩阵相乘

```c
#include <stdio.h>

int main() {
    int matrix_a[10][10];
    int matrix_b[10][10];
    int m;
    int n;
    scanf("%d",&m);
    scanf("%d",&n);
    for(int i = 0; i < m; i++){
        for(int j = 0; j < n; j++){
            scanf("%d", &matrix_a[i][j]);
        }
    }
    for(int i = 0; i < n; i++){
        for(int j = 0; j < m; j++){
            scanf("%d", &matrix_b[i][j]);
        }
    }
    for(int i = 0; i < m; i++){
      for(int z= 0; z < m; z++){
          int a = 0;
        for(int j = 0; j < n; j++){
           a += matrix_a[i][j]*matrix_b[j][z];
        }
        printf("%d",a);
        if(z<m-1){
            printf(" ");
        }else{
            printf("\n");
        }
     }
    }
    return 0;
}
```



### 字符串数组排序

```c
#include <stdio.h>
#include<string.h>
int main() {
    char string[10][21];
    
    for(int i = 0; i < 10; i++){
        scanf("%s",&string[i]);
    }
    char temp[21];
    for(int i = 0; i <10; i++){
        int index = i;
        for(int j = i+1; j < 10; j++){
            if(strcmp(string[index],string[j])>0){
                index = j;
            }
        }
        strcpy(temp,string[index]);
        strcpy(string[index],string[i]);
        strcpy(string[i],temp);
        //printf("%s\n",string[i]);
    }
       for(int i = 0; i <10; i++){
            printf("%s",string[i]);
            if(i < 9){
            printf("\n");
        }
            
  }
    return 0;
}
```

### 输出最长名字

```c
#include <stdio.h>
int main() {
    int n;
    scanf("%d\n", &n);
    char string[100];
     int longth = 0;
    char temp[100];
    for(int j = 0; j < n; j++){
         gets(string);
        if(longth<strlen(string)){
            longth = strlen(string);
            strcpy(temp,string);
        }        //strings[j]=string;
        
    }
    printf("%s",temp);
    return 0;
}
```

### 修改权限

```c
#include <stdio.h>
int main() {
    char cs[1000]={0};
     //char cs1[3];
    int i = 0;
    int bo = 0;
    int nums = 0;
    int j = 0;
    while(scanf("%c",&cs[i++]) != EOF){
        if(bo==0){
                    if(cs[j]=='x'){
                        nums = nums|1;
                    }else if(cs[j]=='w'){
                        nums = nums|2;
                    }else if(cs[j]=='r'){
                        nums = nums|4;
                    }            
            if(cs[j]=='\n'){
                bo = 1;
           }
        }
            if(cs[j-1]=='+'){
                if(cs[j]=='x'){
                    nums = nums|1;
                }else if(cs[j]=='w'){
                    nums = nums|2;
                }else if(cs[j]=='r'){
                    nums = nums|4;
                }
            }
        else if(cs[j-1]=='-'){
                if(cs[j]=='x'){
                    nums = nums-1;
                }else if(cs[j]=='w'){
                    nums = nums-2;
                }else if(cs[j]=='r'){
                    nums = nums-4;
                }
            }                
            j++;
    }
     printf("%d",nums);
    return 0;
}
```

### 哈希转换(32位)

```c
#include <stdio.h>
#include <string.h>
int main() {
    int arr[32] = {0};
    int bits[32] = {0};
    char in[501] = {0};
    scanf("%s",in);
    for(int i = 0; i < strlen(in); i++){
        arr[(i+1) % 32] += (int)(in[i]);
    }
    for(int j = 0; j < 32; j++){
        bits[j] = arr[31-j]^(arr[j]<<1);
    }
    for(int j = 0; j < 32; j++){
         printf("%c",(char)(bits[j] % 85 + 34));
    }
    return 0;
}
```

### 判断点是否在矩阵内

```c
#include <stdio.h>
#include <math.h>

struct point {
    int x;
    int y;
};
struct rectangle {
    struct point p1;
    struct point p2;
};

int main() {
    struct point p1;
    struct rectangle r1;
    scanf("%d %d",&p1.x,&p1.y);
    scanf("%d %d",&r1.p1.x,&r1.p1.y);
    scanf("%d %d",&r1.p2.x,&r1.p2.y);
    if( p1.x>r1.p1.x&&p1.x>r1.p2.x||p1.y>r1.p1.y&&p1.y>r1.p2.y||p1.x<r1.p1.x&&p1.x<r1.p2.x||p1.y<r1.p1.y&&p1.y<r1.p2.y){
        printf("NO");
    }else{
        printf("YES");
    }
    // printf("%d %d\n",p1.x,p1.y);
    // printf("%d %d\n",r1.p2.x,r1.p2.y);
    return 0;
}
```

### 改进约瑟夫

```c
#include <stdio.h>
#include <stdlib.h>
typedef struct node {
    int data;
    struct node *next;
} Node;

Node *circle_create(int n);
void count_off(Node *head, int n, int k, int m);

int main() {
    int n, k, m;
    scanf("%d%d%d", &n, &k, &m);
    Node *head = circle_create(n);
    count_off(head, n, k, m);
    return 0;
}

Node *circle_create(int n) {
    Node *temp, *new_node, *head;
    int i;

    // 创建第一个链表节点并加数据
    temp = (Node *) malloc(sizeof(Node));
    head = temp;
    head->data = 1;

    // 创建第 2 到第 n 个链表节点并加数据
    for(i = 2; i <= n; i++) {
        new_node = (Node *) malloc(sizeof(Node));
        new_node->data = i;
        temp->next = new_node;
        temp = new_node;
    }

    // 最后一个节点指向头部构成循环链表
    temp->next = head;

    return head;
}

void count_off(Node *head, int n, int k, int m) {
    Node *temp;
     Node *temp1;
    temp1 = head;
    for(int i = 1;i < k; i++){
           temp = temp1->next;
            temp1 = temp;
    }
    Node *cur;
    Node *pre3 = head;
    cur = temp1;
    Node *t = head;
    while(pre3->next!=cur){
        pre3 = t;
        t = t->next;
    }
    if(m == 1){       
        while(cur->next!=cur){
            printf("%d ",cur->data);
            pre3->next = cur->next;
            cur = pre3->next;
        }
    }else{
        while(cur->next!=cur){
            Node *pre;
            for(int i = 0;i < m-1; i++){
                pre = cur;
                cur = cur->next;
            }
            printf("%d ",cur->data);
            pre->next = cur->next;
            free(cur);
            cur = pre->next;
        }
    }
    printf("%d",cur->data);
 
    return;
}
```

